"""
V√âRIFICATION FINALE : LES PALINDROMES SONT-ILS DANS LA S√âQUENCE DE 196 ?
=========================================================================

Ce script v√©rifie si les 260 palindromes trouv√©s sont R√âELLEMENT pr√©sents
dans les 601,051 portes K9 issues de la s√©quence de 196.

QUESTION CRUCIALE : Ces palindromes existent math√©matiquement, mais
                    sont-ils ACCESSIBLES depuis 196 ?

Auteur: St√©phane Lefebvre
Date: Octobre 2025
"""

import json
from typing import Tuple, List, Dict, Set
from pathlib import Path

# ============================================================================
# FONCTIONS UTILITAIRES
# ============================================================================

def calculer_porte_complete(n: int, k: int = 9) -> Tuple[int, ...]:
    """Calcule la porte compl√®te d'un nombre √† k chiffres"""
    s = str(n).zfill(k)
    porte = []
    m = (k + 1) // 2
    
    for i in range(m):
        if i == k - 1 - i:  # Position centrale
            porte.append(int(s[i]))
        else:
            porte.append(int(s[i]) + int(s[k - 1 - i]))
    
    return tuple(porte)


def est_palindrome(n: int) -> bool:
    """V√©rifie si un nombre est palindrome"""
    s = str(n)
    return s == s[::-1]


# ============================================================================
# V√âRIFICATION PRINCIPALE
# ============================================================================

def verifier_palindromes_dans_k9(chemin_k9: str, 
                                 chemin_palindromes: str) -> Dict:
    """
    V√©rifie si les palindromes trouv√©s sont dans les portes K9 r√©elles
    """
    print("\n" + "="*70)
    print("üî¨ V√âRIFICATION FINALE : PALINDROMES DANS LA S√âQUENCE DE 196 ?")
    print("="*70 + "\n")
    
    # Charger K9
    print("Chargement de K9_portes.json...")
    with open(chemin_k9, 'r', encoding='utf-8') as f:
        k9 = json.load(f)
    
    # Convertir les portes en set pour recherche rapide
    portes_k9_set = set()
    for porte_list in k9['portes']:
        portes_k9_set.add(tuple(porte_list))
    
    print(f"  ‚úì {len(portes_k9_set):,} portes uniques charg√©es\n")
    
    # Charger les palindromes
    print("Chargement des palindromes trouv√©s...")
    with open(chemin_palindromes, 'r', encoding='utf-8') as f:
        resultats_pal = json.load(f)
    
    palindromes = resultats_pal['palindromes']
    print(f"  ‚úì {len(palindromes)} palindromes √† v√©rifier\n")
    
    # V√©rification
    print("="*70)
    print("V√âRIFICATION EN COURS...")
    print("="*70 + "\n")
    
    resultats = {
        'total_palindromes': len(palindromes),
        'dans_k9': [],
        'hors_k9': [],
        'erreurs': []
    }
    
    for i, pal_info in enumerate(palindromes, 1):
        palindrome = pal_info['nombre']
        porte_declaree = tuple(pal_info['porte'])
        
        # V√©rifier que c'est bien un palindrome
        if not est_palindrome(palindrome):
            resultats['erreurs'].append({
                'palindrome': palindrome,
                'raison': 'Pas un palindrome !'
            })
            continue
        
        # Calculer la porte du palindrome
        porte_calculee = calculer_porte_complete(palindrome, k=9)
        
        # V√©rifier coh√©rence
        if porte_calculee != porte_declaree:
            resultats['erreurs'].append({
                'palindrome': palindrome,
                'raison': f'Porte incoh√©rente: {porte_calculee} != {porte_declaree}'
            })
            continue
        
        # V√©rifier si dans K9
        if porte_calculee in portes_k9_set:
            resultats['dans_k9'].append({
                'palindrome': palindrome,
                'porte': porte_calculee
            })
            print(f"‚ö†Ô∏è  TROUV√â DANS K9 : {palindrome}")
            print(f"    Porte : {porte_calculee}\n")
        else:
            resultats['hors_k9'].append({
                'palindrome': palindrome,
                'porte': porte_calculee
            })
        
        # Progress
        if i % 50 == 0:
            print(f"  V√©rifi√© {i}/{len(palindromes)} palindromes...")
    
    print(f"\n  ‚úì V√©rification termin√©e !\n")
    
    return resultats


# ============================================================================
# RAPPORT FINAL
# ============================================================================

def generer_rapport_final(resultats: Dict):
    """G√©n√®re le rapport final d√©cisif"""
    
    print("\n" + "="*70)
    print("üìä RAPPORT FINAL : V√âRIFICATION COMPL√àTE")
    print("="*70 + "\n")
    
    total = resultats['total_palindromes']
    dans_k9 = len(resultats['dans_k9'])
    hors_k9 = len(resultats['hors_k9'])
    erreurs = len(resultats['erreurs'])
    
    print(f"Palindromes analys√©s : {total}")
    print(f"Palindromes DANS K9 (s√©quence de 196) : {dans_k9}")
    print(f"Palindromes HORS K9 (n'existent pas dans la s√©quence) : {hors_k9}")
    print(f"Erreurs d√©tect√©es : {erreurs}\n")
    
    if erreurs > 0:
        print("‚ö†Ô∏è  ERREURS D√âTECT√âES :")
        print("="*70)
        for err in resultats['erreurs'][:10]:
            print(f"  Palindrome {err['palindrome']} : {err['raison']}")
        print()
    
    if dans_k9 > 0:
        print("="*70)
        print("üö® R√âSULTAT CRITIQUE : PALINDROMES TROUV√âS DANS K9 !")
        print("="*70 + "\n")
        
        print(f"‚ùå {dans_k9} palindrome(s) sont PR√âSENTS dans les portes K9")
        print("   issues de la s√©quence de 196 !\n")
        
        print("Liste des palindromes dans K9 :")
        for pal in resultats['dans_k9'][:20]:
            print(f"  ‚Ä¢ {pal['palindrome']} (porte : {pal['porte']})")
        
        if len(resultats['dans_k9']) > 20:
            print(f"  ... et {len(resultats['dans_k9']) - 20} autres")
        
        print("\n" + "="*70)
        print("üí• IMPLICATIONS MAJEURES")
        print("="*70 + "\n")
        
        print("Ceci signifie que :")
        print("  1. Ces palindromes PEUVENT √™tre atteints depuis 196")
        print("  2. La conjecture de Lychrel pour 196 est FAUSSE")
        print("  3. OU il y a une erreur dans les donn√©es K9")
        print("")
        print("‚ö†Ô∏è  V√âRIFICATIONS N√âCESSAIRES :")
        print("  ‚Ä¢ Tracer la trajectoire de 196 vers ces palindromes")
        print("  ‚Ä¢ V√©rifier que ces nombres sont bien dans la s√©quence")
        print("  ‚Ä¢ Revalider les donn√©es K9")
        
    else:
        print("="*70)
        print("‚úÖ R√âSULTAT : AUCUN PALINDROME DANS K9 !")
        print("="*70 + "\n")
        
        print(f"üéØ LES {total} PALINDROMES EXISTENT MATH√âMATIQUEMENT")
        print("   MAIS NE SONT PAS DANS LA S√âQUENCE DE 196 !\n")
        
        print("Ce r√©sultat confirme :")
        print("  ‚úì Les 180 signatures forment un ensemble FERM√â")
        print("  ‚úì Cet ensemble ne contient AUCUN palindrome")
        print("  ‚úì Les 260 palindromes existent ailleurs dans ‚Ñï")
        print("  ‚úì Mais 196 ne peut PAS les atteindre\n")
        
        print("="*70)
        print("üèÜ CONCLUSION D√âFINITIVE")
        print("="*70 + "\n")
        
        print("‚úÖ PREUVE COMPUTATIONNELLE COMPL√àTE :")
        print("")
        print("   1. Les 180 signatures sont FERM√âES sous T")
        print("   2. AUCUNE signature ne correspond √† un palindrome")
        print("      accessible depuis 196")
        print("   3. Les palindromes trouv√©s (260) existent mais sont")
        print("      HORS de la s√©quence de 196")
        print("")
        print("   Ceci constitue une FORTE √âVIDENCE COMPUTATIONNELLE")
        print("   que 196 est un v√©ritable nombre de Lychrel.")
        print("")
        print(f"   Test effectu√© sur {total} palindromes potentiels")
        print("   et 601,051 nombres candidats Lychrel √† 9 chiffres.")
    
    print("\n" + "="*70 + "\n")


# ============================================================================
# ANALYSE SUPPL√âMENTAIRE
# ============================================================================

def analyser_distribution_palindromes(resultats: Dict):
    """Analyse la distribution des palindromes hors K9"""
    
    if len(resultats['hors_k9']) == 0:
        return
    
    print("\n" + "="*70)
    print("üìä ANALYSE : O√ô SONT CES PALINDROMES ?")
    print("="*70 + "\n")
    
    # Analyser les portes des palindromes hors K9
    signatures_hors = {}
    for pal in resultats['hors_k9']:
        sig = (pal['porte'][0], pal['porte'][-1])
        if sig not in signatures_hors:
            signatures_hors[sig] = []
        signatures_hors[sig].append(pal['palindrome'])
    
    print(f"Ces {len(resultats['hors_k9'])} palindromes ont")
    print(f"{len(signatures_hors)} signatures diff√©rentes :\n")
    
    for sig in sorted(signatures_hors.keys())[:10]:
        nb = len(signatures_hors[sig])
        exemples = signatures_hors[sig][:3]
        print(f"  Signature {sig} : {nb} palindromes")
        print(f"    Exemples : {', '.join(map(str, exemples))}")
    
    print("\nCes palindromes existent dans ‚Ñï mais ne sont PAS")
    print("produits par la s√©quence de 196 !")
    print("")
    print("Explication : La transformation reverse-and-add sur 196")
    print("g√©n√®re un sous-ensemble STRICT de tous les nombres possibles.")
    print("Les palindromes trouv√©s sont dans le compl√©ment de cet ensemble.")


# ============================================================================
# PROGRAMME PRINCIPAL
# ============================================================================

def main():
    """Programme principal"""
    
    print("\n" + "="*70)
    print("üî¨ V√âRIFICATION FINALE : CONJECTURE DE LYCHREL")
    print("="*70)
    print("\nObjectif : V√©rifier si les 260 palindromes trouv√©s")
    print("          sont accessibles depuis 196\n")
    
    # Chemins
    chemin_k9 = r"F:\Dossier_Lychrel_Important\Dossier_Complet\Listes_Portes\K9\K9_portes.json"
    chemin_palindromes = "resultats_analyse_palindromes.json"
    
    # V√©rifier que les fichiers existent
    if not Path(chemin_k9).exists():
        print(f"‚ùå Fichier {chemin_k9} introuvable !")
        return
    
    if not Path(chemin_palindromes).exists():
        print(f"‚ùå Fichier {chemin_palindromes} introuvable !")
        print("   Ex√©cutez d'abord analyse_palindrome_approfondie.py")
        return
    
    # V√©rification
    resultats = verifier_palindromes_dans_k9(chemin_k9, chemin_palindromes)
    
    # Rapport final
    generer_rapport_final(resultats)
    
    # Analyse suppl√©mentaire
    if len(resultats['hors_k9']) > 0:
        analyser_distribution_palindromes(resultats)
    
    # Sauvegarder
    resultats_json = {
        'total_palindromes': resultats['total_palindromes'],
        'nb_dans_k9': len(resultats['dans_k9']),
        'nb_hors_k9': len(resultats['hors_k9']),
        'nb_erreurs': len(resultats['erreurs']),
        'palindromes_dans_k9': resultats['dans_k9'],
        'palindromes_hors_k9': [p['palindrome'] for p in resultats['hors_k9'][:100]],
        'verdict': 'PALINDROMES_DANS_K9' if len(resultats['dans_k9']) > 0 else 'AUCUN_PALINDROME_DANS_K9'
    }
    
    with open('verification_finale.json', 'w', encoding='utf-8') as f:
        json.dump(resultats_json, f, indent=2)
    
    print("üíæ R√©sultats sauvegard√©s dans 'verification_finale.json'\n")


if __name__ == "__main__":
    main()